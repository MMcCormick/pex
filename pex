#!/bin/sh

usage="\
pex is a PostgreSQL package manager.

Usage:
  pex audit [PACKAGE]...
  pex cat PACKAGE...
  pex create -n NAME URL
  pex edit [PACKAGE]...
  pex fetch PACKAGE...
  pex home [PACKAGE]...
  pex info PACKAGE...
  pex init [REPO]
  pex install PACKAGE
  pex ls|list
  pex outdated
  pex repotest
  pex search [SUBSTRING]
  pex update [--rebase]
  pex upgrade [PACKAGE]...
"

PEX_HOMEPAGE='https://github.com/petere/pex'
PEX_DEFAULT_REMOTE='git://github.com/petere/pex-packages.git'

set -eu

: ${XDG_DATA_HOME=$HOME/.local/share}
: ${XDG_CONFIG_HOME=$HOME/.config}
: ${XDG_CACHE_HOME=$HOME/.cache}

LC_COLLATE=C
export LC_COLLATE

exec 6>&1

error() {
	echo "pex: $@" 1>&2
	exit 1
}

output() {
	echo "==> $@" 1>&6
}

assert() {
	if test "$@"; then
		:
	else
		set +u
		if test -n "$BASH"; then
			error "assertion failed: $@ (${FUNCNAME[1]})"
		else
			error "assertion failed: $@"
		fi
	fi
}


data_dir=$XDG_DATA_HOME/pex
packages_dir=$data_dir/packages
work_dir=$XDG_CACHE_HOME/pex


if which gmake >/dev/null; then
	gnumake=gmake
else
	gnumake=make
fi


cmd_audit() {
	local pkg all_packages

	if [ $# -gt 0 ]; then
		for pkg; do
			_audit_one "$pkg"
		done
	else
		all_packages=$(_all_packages)
		for pkg in $all_packages; do
			_audit_one "$pkg"
		done
	fi
	output "Looks good"
}


cmd_cat() {
	local pkg package_file

	if [ $# -eq 0 ]; then
		error '"cat" takes at least one argument'
	fi

	for pkg; do
		package_file=$(_package_file "$pkg")
		cat "$package_file"
	done
}


cmd_edit() {
	local file files

	files=''

	if [ $# -eq 0 ]; then
		set $(cmd_search)
	fi
	for pkg; do
		file=$(_package_file "$pkg")
		files="$files $file"
	done

	_editor $files
}


cmd_create() {
	local downloaded_sha1 package_file pkg target url

	pkg=''

	while getopts 'n:' opt; do
		case $opt in
			n)
				pkg=$OPTARG;;
			*)
				exit 1;;
		esac
	done
	shift $(($OPTIND - 1))

	if [ $# -ne 1 ]; then
		error '"create" takes exactly one nonoption argument'
	fi

	# TODO: optionally autodetect name
	if [ -z "$pkg" ]; then
		error "name must be specified (-n)"
	fi

	if [ -e "$packages_dir/$pkg.yaml" ]; then
		error "package \"$pkg\" already exists (use \"pex edit\" to change it)"
	fi

	url=$1
	target=$(_download_target "$pkg" "$url")
	download "$url" "$target"
	downloaded_sha1=$(_sha1 "$target")
	package_file=$(_package_file "$pkg" true)
	cat <<EOF >"$package_file"
homepage: FIXME
url: $url
sha1: $downloaded_sha1
EOF
	cmd_edit "$pkg"
	echo "Use \"pex audit $pkg\" to check the package description."
}


cmd_fetch() {
	local pkg

	for pkg; do
		_fetch_one "$pkg" >/dev/null
	done
}


cmd_home() {
	local homepage homepages package_file pkg

	homepages=''

	if [ $# -gt 0 ]; then
		for pkg; do
			package_file=$(_package_file "$pkg")
			homepage=$(parse_yaml_field "$package_file" homepage)
			homepages="$homepages $homepage"
		done
	else
		homepages=$PEX_HOMEPAGE
	fi

	_browser $homepages
}


cmd_info() {
	local pkg

	if [ $# -eq 0 ]; then
		error '"info" takes at least one argument'
	fi

	for pkg; do
		_info_one "$pkg"
	done
}


cmd_init() {
	local remote

	if [ $# -eq 0 ]; then
		remote=$PEX_DEFAULT_REMOTE
	elif [ $# -eq 1 ]; then
		remote=$1
	else
		error '"init" takes zero or one arguments'
	fi
	mkdir -p "$data_dir"
	(
		cd "$data_dir"
		git clone $remote packages
	)
}


cmd_install() {
	local pkg

	for pkg in "$@"; do
		_install_one "$pkg" false
	done
}


cmd_list() {
	if [ $# -gt 0 ]; then
		error '"list" takes no arguments'
	fi

	if [ ! -d "$installed_dir" ]; then
		return
	fi

	(
		cd "$installed_dir"
		ls -1 *.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
	)

}


cmd_outdated() {
	local installed_file pkg

	if [ $# -gt 0 ]; then
		error '"outdated" takes no arguments'
	fi

	if [ ! -d "$installed_dir" ]; then
		return
	fi

	for installed_file in $(find "$installed_dir" -name "*.yaml" -print); do
		pkg=$(basename "$installed_file" | sed 's/\.yaml$//')
		if _is_outdated "$pkg"; then
			echo "$pkg"
		fi
	done
}


cmd_repotest() {
	local i out pkg ret

	set $(cmd_search)
	echo "1..$#"
	ret=0
	i=0
	for pkg; do
		i=$(($i + 1))
		status=0
		out=$(_fetch_one "$pkg" 2>&1 6>&1) || status=$?
		if [ $status -eq 0 ]; then
			echo "ok $i $pkg"
		else
			echo "not ok $i $pkg"
			echo "$out" | grep -E -v '#+ 100\.0%' | sed 's/^/    # /'
			ret=1
		fi
	done
	exit $ret
}


cmd_search() {
	if [ $# -gt 1 ]; then
		error '"search" takes zero or one arguments'
	fi
	(
		cd "$packages_dir"
		if [ $# -gt 0 ]; then
			ls -1 *"$1"*.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
		else
			ls -1 *.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
		fi
	)
}


cmd_update() {
	local changes
	(
		cd "$packages_dir"
		git pull -n "$@"
		changes=$(git diff ORIG_HEAD..HEAD --name-status *.yaml | sed 's/\.yaml$//')
		if echo "$changes" | grep -q '^A'; then
			output "New packages"
			echo "$changes" | sed -n 's/^A[[:space:]]*//p' | sort
		fi
		if echo "$changes" | grep -q '^M'; then
			output "Updated packages"
			echo "$changes" | sed -n 's/^M[[:space:]]*//p' | sort
		fi
	)
}


cmd_upgrade() {
	local pkg

	if [ $# -gt 0 ]; then
		for pkg; do
			_upgrade_one "$pkg"
		done
	else
		for pkg in $(cmd_list); do
			_upgrade_one "$pkg"
		done
	fi
}


_all_packages() {
	assert $# -eq 0
	(
		cd "$packages_dir"
		ls -1 *.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
	)
}


_browser() {
	assert $# -ge 1

	set +u
	if [ -n "$BROWSER" ]; then
		$BROWSER "$@"
	elif [ $(uname -s) = 'Darwin' ]; then
		open "$@"
	elif which xdg-open >/dev/null; then
		xdg-open "$@"
	elif which sensible-browser >/dev/null; then
		sensible-browser "$@"
	else
		error "cannot find a suitable browser"
	fi
	set -u
}


_editor() {
	assert $# -gt 0

	set +u
	if [ -n "$EDITOR" ]; then
		$EDITOR "$@"
	elif which sensible-editor >/dev/null; then
		sensible-editor "$@"
	else
		vi "$@"
	fi
	set -u
}


_package_file() {
	local filename pkg ignore_missing

	assert $# -eq 1 -o $# -eq 2
	pkg=$1
	ignore_missing=false
	if [ $# -ge 2 ]; then
		ignore_missing=$2
	fi

	if [ ! -d "$packages_dir" ]; then
		error "packages directory \"$packages_dir\" does not exist (Did you run \"pex init\"?)"
	fi
	filename="$packages_dir/$pkg.yaml"
	if [ ! -f "$filename" ] && ! $ignore_missing; then
		error "package \"$pkg\" does not exist"
	fi
	echo "$filename"
}


_audit_one() {
	local homepage package_file pkg

	assert $# -eq 1
	pkg=$1
	output "Auditing $pkg"

	package_file=$(_package_file "$pkg")

	perl -MYAML -e 'use YAML;YAML::LoadFile("'"$package_file"'")'
	homepage=$(parse_yaml_field "$package_file" homepage)
	parse_yaml_field "$package_file" url >/dev/null
	parse_yaml_field "$package_file" sha1 >/dev/null

	if [ "$homepage" = FIXME ] || [ -z "$homepage" ]; then
		error "homepage field not filled in correctly"
	fi
}


_fetch_one() {
	local downloaded_sha1 package_file pkg sha1 target url

	assert $# -eq 1
	pkg=$1

	package_file=$(_package_file "$pkg")
	if [ ! -f "$package_file" ]; then
		error "package file \"$package_file\" does not exist"
	fi

	url=$(parse_yaml_field "$package_file" url)
	sha1=$(parse_yaml_field "$package_file" sha1)

	target=$(_download_target "$pkg" "$url")

	if [ -f "$target" ] && [ $(_sha1 "$target") = "$sha1" ]; then
		output "Already downloaded $pkg"
	else
		download "$url" "$target"
		downloaded_sha1=$(_sha1 "$target")
		if [ "$downloaded_sha1" != "$sha1" ]; then
			error "SHA1 mismatch\nExpected: $sha1\nActual: $downloaded_sha1"
		fi
	fi
	echo "$target"
}


_download_target() {
	local ext pkg url

	assert $# -eq 2
	pkg=$1
	url=$2

	mkdir -p "$work_dir/$pkg/download"
	write_cachedir_tag "$work_dir"

	ext=$(canonical_archive_extension "$url")
	echo "$work_dir/$pkg/download/$pkg.$ext"
}


_info_one() {
	local homepage package_file pkg status url

	assert $# -eq 1
	pkg=$1

	package_file=$(_package_file "$pkg")
	if [ ! -f "$package_file" ]; then
		error "package file \"$package_file\" does not exist"
	fi

	homepage=$(parse_yaml_field "$package_file" homepage)
	url=$(parse_yaml_field "$package_file" url)

	if [ ! -e "$installed_dir/$pkg.yaml" ]; then
		status='not installed'
	elif _is_outdated "$pkg"; then
		status='outdated'
	else
		status='installed'
	fi

	echo "$pkg"
	echo "homepage: $homepage"
	echo "url: $url"
	echo "status: $status"
}


_install_one() {
	local allow_upgrade package_file pkg target

	assert $# -eq 2
	pkg=$1
	allow_upgrade=$2

	if [ -e "$installed_dir/$pkg.yaml" ] && ! $allow_upgrade; then
		error "package \"$pkg\" is already installed"
	fi

	target=$(_fetch_one "$pkg")

	rm -rf "$work_dir/$pkg/build"
	mkdir -p "$work_dir/$pkg/build"
	write_cachedir_tag "$work_dir"

	(
		cd "$work_dir/$pkg/build"
		output "Unpacking $pkg"
		unpack "$target"
		cd "$pkg"*  # FIXME
		output "Building $pkg"
		if [ -x configure ]; then
			./configure \
				--bindir=$("$pg_config" --bindir) \
				--includedir=$("$pg_config" --includedir) \
				--libdir=$("$pg_config" --libdir) \
				--with-pgconfig=$("$pg_config" --bindir)/pg_config
		fi
		"$gnumake" all USE_PGXS=1 PG_CONFIG="$pg_config"
		output "Installing $pkg"
		$sudo "$gnumake" install USE_PGXS=1 PG_CONFIG="$pg_config"
	)

	package_file=$(_package_file "$pkg")
	$sudo mkdir -p "$installed_dir"
	$sudo cp "$package_file" "$installed_dir/"

	output "Package $pkg installed successfully"
}


_is_outdated() {
	local available_file available_sha1 installed_file installed_sha1 pkg

	assert $# -eq 1
	pkg=$1
	installed_file=$installed_dir/$pkg.yaml

	installed_sha1=$(parse_yaml_field "$installed_file" sha1)
	available_file=$(_package_file "$pkg")
	if [ -e "$available_file" ]; then
		available_sha1=$(parse_yaml_field "$available_file" sha1)
		if [ "$installed_sha1" != "$available_sha1" ]; then
			return 0
		fi
	else
		return 0
	fi
	return 1
}


_sha1() {
	assert $# -eq 1
	sha1sum "$1" | cut -d ' ' -f 1
}


_upgrade_one() {
	local installed_sha1 new_sha1 package_file pkg

	assert $# -eq 1
	pkg="$1"

	if [ ! -e "$installed_dir/$pkg.yaml" ]; then
		error "package \"$pkg\" is not installed"
	fi

	package_file=$(_package_file "$pkg")

	installed_sha1=$(parse_yaml_field "$installed_dir/$pkg.yaml" sha1)
	new_sha1=$(parse_yaml_field "$package_file" sha1)

	if [ "$installed_sha1" = "$new_sha1" ]; then
		output "Package $pkg already up to date"
		return
	fi

	_install_one "$pkg" true
}


parse_yaml_field() {
	local field file val

	assert $# -eq 2
	file=$1
	field=$2

	val=$(cat "$file" | sed -n "s/^${field}: *//p")

	if [ -z "$val" ]; then
		error "field \"$field\" missing in file \"$file\""
	fi

	echo "$val"
}


canonical_archive_extension() {
	local file

	assert $# -eq 1
	file=$1

	case $file in
		*.zip)
			echo "zip";;
		*.tgz)
			echo "tar.gz";;
		*.tbz2)
			echo "tar.bz2";;
		*.tar.*)
			echo "$file" | sed 's,^.*\.\(tar\..*\)$,\1,';;
		*.git)
			echo "git";;
	esac
}


download() {
	local ext target url

	assert $# -eq 2
	url=$1
	target=$2
	ext=$(canonical_archive_extension "$target")

	output "Downloading $pkg from $url"

	case $ext in
		git)
			git clone --depth=1 "$url" "$target";;
		*)
			curl --progress-bar --location -o "$target" "$url";;
	esac
}


unpack() {
	local ext file

	assert $# -eq 1
	file=$1
	ext=$(canonical_archive_extension "$file")

        # FIXME: check directory structure
	case $ext in
		zip)
			unzip "$file";;
		tar.*)
			tar xvf "$file";;
		git)
			;;
		*)
			error "unsupported archive format: $file";;
	esac
}


write_cachedir_tag() {
	local dir

	assert $# -eq 1
	dir=$1

	if [ -e "$dir/CACHEDIR.TAG" ]; then
		return
	fi

	cat >$dir/CACHEDIR.TAG <<EOF
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pex.
# For information about cache directory tags, see:
#	http://www.brynosaurus.com/cachedir/
EOF
}


_pg_config_from_datadir() {
	assert $# -eq 1
	cat "$1/postmaster.opts" | awk '{ print $1 }' | sed 's,/postgres$,/pg_config,'
}


psql() {
	command psql -X "$@"
}


case $1 in
	--help|-\?)
		echo "$usage"; exit 0;;
	--cache)
		echo "$work_dir"; exit 0;;
	--repo|--repository)
		echo "$packages_dir"; exit 0;;
esac


pg_config=
sudo=

while getopts 'd:Dg:Gp:PS' opt; do
	case $opt in
		g)
			if [ -d "$OPTARG" ] && [ -e "$OPTARG/bin/pg_config" ]; then
				pg_config=$OPTARG/bin/pg_config
			elif [ -d "$OPTARG" ] && [ -e "$OPTARG/pg_config" ]; then
				pg_config=$OPTARG/pg_config
			else
				pg_config=$OPTARG
			fi
			;;
		G)
			pg_config=
			;;
		d)
			pg_config=$(_pg_config_from_datadir "$OPTARG")
			;;
		D)
			pg_config=$(_pg_config_from_datadir "$PGDATA")
			;;
		p)
			pg_config=$(_pg_config_from_datadir $(psql -At -p "$OPTARG" -c 'show data_directory'))
			;;
		P)
			pg_config=$(_pg_config_from_datadir $(psql -At -c 'show data_directory'))
			;;
		S)
			sudo=sudo
			;;
		*)
			exit 1
			;;
	esac
done

shift $(($OPTIND - 1))

if [ -z "$pg_config" ]; then
	pg_config=pg_config
else
	# convert to absolute path
	_pg_config_dir=$(dirname "$pg_config")
	_pg_config_base=$(basename "$pg_config")
	_pg_config_dir=$(cd "$_pg_config_dir" && pwd)
	pg_config=$_pg_config_dir/$_pg_config_base
fi

pgsharedir=$("$pg_config" --sharedir)
installed_dir=$pgsharedir/pex/installed


command=$1
shift

case $command in
	audit)
		cmd_audit "$@";;
	cat)
		cmd_cat "$@";;
	create)
		cmd_create "$@";;
	edit)
		cmd_edit "$@";;
	fetch)
		cmd_fetch "$@";;
	home)
		cmd_home "$@";;
	info)
		cmd_info "$@";;
	init)
		cmd_init "$@";;
	install)
		cmd_install "$@";;
	ls|list)
		cmd_list "$@";;
	outdated)
		cmd_outdated "$@";;
	repotest)
		cmd_repotest "$@";;
	search)
		cmd_search "$@";;
	update)
		cmd_update "$@";;
	upgrade)
		cmd_upgrade "$@";;
	help)
		echo "$usage";;
	*)
		error "invalid command: $command";;
esac
