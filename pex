#!/bin/sh

usage="\
pex is a PostgreSQL package manager.

Usage:
  pex audit [PACKAGE]...
  pex cat PACKAGE
  pex fetch PACKAGE...
  pex home [PACKAGE]
  pex info PACKAGE...
  pex init
  pex install PACKAGE
  pex ls|list
  pex outdated
  pex search SUBSTRING
  pex update [--rebase]
  pex upgrade [PACKAGE]...
"

PEX_HOMEPAGE='https://github.com/petere/pex'
PEX_DEFAULT_REMOTE='git://github.com/petere/pex-packages.git'

set -eu

: ${XDG_DATA_HOME=$HOME/.local/share}
: ${XDG_CONFIG_HOME=$HOME/.config}
: ${XDG_CACHE_HOME=$HOME/.cache}

LC_COLLATE=C
export LC_COLLATE

exec 6>&1

error() {
	echo "pex: $@" 1>&2
	exit 1
}

output() {
	echo "==> $@" 1>&6
}


data_dir=$XDG_DATA_HOME/pex
packages_dir=$data_dir/packages
work_dir=$XDG_CACHE_HOME/pex


if which gmake >/dev/null; then
	gnumake=gmake
else
	gnumake=make
fi


cmd_audit() {
	local pkg

	if [ $# -gt 0 ]; then
		for pkg; do
			_audit_one "$pkg"
		done
	else
		local all_packages=$(_all_packages)
		for pkg in $all_packages; do
			_audit_one "$pkg"
		done
	fi
	output "Looks good"
}


cmd_cat() {
	local package_file=$(_package_file "$1")
	cat "$package_file"
}


cmd_fetch() {
	local pkg

	for pkg; do
		_fetch_one "$pkg" >/dev/null
	done
}


cmd_home() {
	if [ $# -gt 0 ]; then
		local package_file=$(_package_file "$1")
		local homepage=$(parse_yaml_field "$package_file" homepage)
	else
		local homepage=$PEX_HOMEPAGE
	fi

	_browser "$homepage"
}


cmd_info() {
	local pkg

	for pkg; do
		_info_one "$pkg"
	done
}


cmd_init() {
	local remote
	if [ $# -gt 0 ]; then
		remote=$1
	else
		remote=$PEX_DEFAULT_REMOTE
	fi
	mkdir -p "$data_dir"
	(
		cd "$data_dir"
		git clone $remote packages
	)
}


cmd_install() {
	local pkg

	for pkg in "$@"; do
		_install_one "$pkg" false
	done
}


cmd_list() {
	if [ ! -d "$installed_dir" ]; then
		return
	fi

	(
		cd "$installed_dir"
		ls -1 *.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
	)

}


cmd_outdated() {
	local installed_file

	if [ ! -d "$installed_dir" ]; then
		return
	fi

	for installed_file in $(find "$installed_dir" -name "*.yaml" -print); do
		local pkg=$(basename "$installed_file" | sed 's/\.yaml$//')
		if _is_outdated "$pkg"; then
			echo "$pkg"
		fi
	done
}


cmd_search() {
	local string=$1

	(
		cd "$packages_dir"
		ls -1 *"$string"*.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
	)
}


cmd_update() {
	(
		cd "$packages_dir"
		git pull "$@"
	)
}


cmd_upgrade() {
	local pkg

	if [ $# -gt 0 ]; then
		for pkg; do
			_upgrade_one "$pkg"
		done
	else
		for pkg in $(cmd_list); do
			_upgrade_one "$pkg"
		done
	fi
}


_all_packages() {
	(
		cd "$packages_dir"
		ls -1 *.yaml 2>/dev/null | sed 's/\.yaml$//' | sort
	)
}


_browser() {
	local page=$1

	set +u
	if [ -n "$BROWSER" ]; then
		$BROWSER "$page"
	elif [ $(uname -s) = 'Darwin' ]; then
		open "$page"
	elif which xdg-open >/dev/null; then
		xdg-open "$page"
	elif which sensible-browser >/dev/null; then
		sensible-browser "$page"
	else
		error "cannot find a suitable browser"
	fi
	set -u
}


_package_file() {
	if [ ! -d "$packages_dir" ]; then
		error "packages directory \"$packages_dir\" does not exist (Did you run \"pex init\"?)"
	fi
	echo "$packages_dir/$1.yaml"
}


_audit_one() {
	local pkg=$1
	output "Auditing $pkg"

	local package_file=$(_package_file "$pkg")

	perl -MYAML -e 'use YAML;YAML::LoadFile("'"$package_file"'")'
	parse_yaml_field "$package_file" homepage >/dev/null
	parse_yaml_field "$package_file" url >/dev/null
	parse_yaml_field "$package_file" sha1 >/dev/null
}


_fetch_one() {
	local pkg=$1

	local package_file=$(_package_file "$pkg")
	if [ ! -f "$package_file" ]; then
		error "package file \"$package_file\" does not exist"
	fi

	local url=$(parse_yaml_field "$package_file" url)
	local sha1=$(parse_yaml_field "$package_file" sha1)

	mkdir -p "$work_dir/$pkg/download"
	write_cachedir_tag "$work_dir"
	local ext=$(canonical_archive_extension "$url")
	local target="$work_dir/$pkg/download/$pkg.$ext"
	download "$url" "$target" "$sha1"
	local downloaded_sha1=$(_sha1 "$target")
	if [ "$downloaded_sha1" != "$sha1" ]; then
		error "SHA1 mismatch"
	fi
	echo "$target"
}


_info_one() {
	local pkg=$1

	local package_file=$(_package_file "$pkg")
	if [ ! -f "$package_file" ]; then
		error "package file \"$package_file\" does not exist"
	fi

	local homepage=$(parse_yaml_field "$package_file" homepage)
	local url=$(parse_yaml_field "$package_file" url)

	local status
	if [ ! -e "$installed_dir/$pkg.yaml" ]; then
		status='not installed'
	elif _is_outdated "$pkg"; then
		status='outdated'
	else
		status='installed'
	fi

	echo "$pkg"
	echo "homepage: $homepage"
	echo "url: $url"
	echo "status: $status"
}


_install_one() {
	local pkg=$1
	local allow_upgrade=$2

	if [ -e "$installed_dir/$pkg.yaml" ] && ! $allow_upgrade; then
		error "package \"$pkg\" is already installed"
	fi

	local target=$(_fetch_one "$pkg")

	rm -rf "$work_dir/$pkg/build"
	mkdir -p "$work_dir/$pkg/build"
	write_cachedir_tag "$work_dir"

	(
		cd "$work_dir/$pkg/build"
		output "Unpacking $pkg"
		unpack "$target"
		cd "$pkg"*  # FIXME
		output "Building $pkg"
		"$gnumake" all USE_PGXS=1 PG_CONFIG="$pg_config"
		output "Installing $pkg"
		"$gnumake" install USE_PGXS=1 PG_CONFIG="$pg_config"
	)

	local package_file=$(_package_file "$pkg")
	mkdir -p "$installed_dir"
	cp "$package_file" "$installed_dir/"

	output "Package $pkg installed successfully"
}


_is_outdated() {
	local pkg=$1
	local installed_file=$installed_dir/$pkg.yaml

	local installed_sha1=$(parse_yaml_field "$installed_file" sha1)
	local available_file=$(_package_file "$pkg")
	if [ -e "$available_file" ]; then
		local available_sha1=$(parse_yaml_field "$available_file" sha1)
		if [ "$installed_sha1" != "$available_sha1" ]; then
			return 0
		fi
	else
		return 0
	fi
	return 1
}


_sha1() {
	sha1sum "$1" | cut -d ' ' -f 1
}


_upgrade_one() {
	local pkg="$1"

	if [ ! -e "$installed_dir/$pkg.yaml" ]; then
		error "package \"$pkg\" is not installed"
	fi

	local package_file=$(_package_file "$pkg")

	local installed_sha1=$(parse_yaml_field "$installed_dir/$pkg.yaml" sha1)
	local new_sha1=$(parse_yaml_field "$package_file" sha1)

	if [ "$installed_sha1" = "$new_sha1" ]; then
		output "Package $pkg already up to date"
		return
	fi

	_install_one "$pkg" true
}

parse_yaml_field() {
	local file=$1
	local field=$2
	local val

	val=$(cat "$file" | sed -n -r "s/^${field}: *//p")

	if [ -z "$val" ]; then
		error "field \"$field\" missing in file \"$file\""
	fi

	echo "$val"
}


canonical_archive_extension() {
	local file=$1

	case $file in
		*.zip)
			echo "zip";;
		*.tgz)
			echo "tar.gz";;
		*.tbz2)
			echo "tar.bz2";;
		*.tar.*)
			echo "$file" | sed 's,^.*\.\(tar\..*\)$,\1,';;
		*.git)
			echo "git";;
	esac
}


download() {
	local url=$1
	local target=$2
	local sha1=$3
	local ext=$(canonical_archive_extension "$target")

	if [ -f "$target" ] && [ $(_sha1 "$target") = "$sha1" ]; then
		output "Already downloaded $pkg"
		return
	fi

	output "Downloading $pkg from $url"

	case $ext in
		git)
			git clone --depth=1 "$url" "$target";;
		*)
			curl --progress-bar --location -o "$target" "$url";;
	esac
}


unpack() {
	local file=$1
	local ext=$(canonical_archive_extension "$file")

        # FIXME: check directory structure
	case $ext in
		zip)
			unzip "$file";;
		tar.*)
			tar xvf "$file";;
		git)
			;;
		*)
			error "unsupported archive format: $file";;
	esac
}


write_cachedir_tag() {
	local dir=$1

	if [ -e "$dir/CACHEDIR.TAG" ]; then
		return
	fi

	cat >$dir/CACHEDIR.TAG <<EOF
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pex.
# For information about cache directory tags, see:
#	http://www.brynosaurus.com/cachedir/
EOF
}


_pg_config_from_datadir() {
	cat "$1/postmaster.opts" | awk '{ print $1 }' | sed 's,/postgres$,/pg_config,'
}


psql() {
	command psql -X "$@"
}


case $1 in
	--help|-\?)
		echo "$usage"; exit 0;;
	--cache)
		echo "$work_dir"; exit 0;;
	--repo|--repository)
		echo "$packages_dir"; exit 0;;
esac


pg_config=

while getopts 'd:Dg:Gp:P' opt; do
	case $opt in
		g)
			if [ -d "$OPTARG" ] && [ -e "$OPTARG/bin/pg_config" ]; then
				pg_config=$OPTARG/bin/pg_config
			elif [ -d "$OPTARG" ] && [ -e "$OPTARG/pg_config" ]; then
				pg_config=$OPTARG/pg_config
			else
				pg_config=$OPTARG
			fi
			;;
		G)
			pg_config=
			;;
		d)
			pg_config=$(_pg_config_from_datadir "$OPTARG")
			;;
		D)
			pg_config=$(_pg_config_from_datadir "$PGDATA")
			;;
		p)
			pg_config=$(_pg_config_from_datadir $(psql -At -p "$OPTARG" -c 'show data_directory'))
			;;
		P)
			pg_config=$(_pg_config_from_datadir $(psql -At -c 'show data_directory'))
			;;
		*)
			exit 1
			;;
	esac
done

shift $(($OPTIND - 1))

if [ -z "$pg_config" ]; then
	pg_config=pg_config
fi

pgsharedir=$("$pg_config" --sharedir)
installed_dir=$pgsharedir/pex/installed


command=$1
shift

case $command in
	audit)
		cmd_audit "$@";;
	cat)
		cmd_cat "$@";;
	fetch)
		cmd_fetch "$@";;
	home)
		cmd_home "$@";;
	info)
		cmd_info "$@";;
	init)
		cmd_init "$@";;
	install)
		cmd_install "$@";;
	ls|list)
		cmd_list "$@";;
	outdated)
		cmd_outdated "$@";;
	search)
		cmd_search "$@";;
	update)
		cmd_update "$@";;
	upgrade)
		cmd_upgrade "$@";;
	help)
		echo "$usage";;
	*)
		error "invalid command: $command";;
esac
